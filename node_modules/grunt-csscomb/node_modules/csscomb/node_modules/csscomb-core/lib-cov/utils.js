
  // instrument by jscoverage, do not modifly this file
  (function(file, lines, conds, source) {
      var BASE;
      if (typeof global === "object") {
          BASE = global;
      } else if (typeof window === "object") {
          BASE = window;
      } else {
          throw new Error("[jscoverage] unknow ENV!");
      }
      if (BASE._$jscoverage) {
          BASE._$jscmd(file, "init", lines, conds, source);
          return;
      }
      var cov = {};
      /**
   * jsc(file, 'init', lines, condtions)
   * jsc(file, 'line', lineNum)
   * jsc(file, 'cond', lineNum, expr, start, offset)
   */
      function jscmd(file, type, line, express, start, offset) {
          var storage;
          switch (type) {
            case "init":
              if (cov[file]) {
                  storage = cov[file];
              } else {
                  storage = [];
                  for (var i = 0; i < line.length; i++) {
                      storage[line[i]] = 0;
                  }
                  var condition = express;
                  var source = start;
                  storage.condition = condition;
                  storage.source = source;
              }
              cov[file] = storage;
              break;

            case "line":
              storage = cov[file];
              storage[line]++;
              break;

            case "cond":
              storage = cov[file];
              storage.condition[line]++;
              return express;
          }
      }
      BASE._$jscoverage = cov;
      BASE._$jscmd = jscmd;
      jscmd(file, "init", lines, conds, source);
  })("lib/utils.js", [1,2,3,4,11,423,12,14,16,18,20,22,24,26,28,29,234,268,294,304,308,318,342,365,394,420,38,39,47,48,49,51,66,54,56,58,60,63,68,69,70,71,85,88,89,106,107,117,120,124,126,143,147,160,166,164,176,178,188,191,179,180,182,189,202,205,206,207,211,235,241,256,258,238,243,249,253,269,270,271,272,273,277,291,274,281,285,295,305,309,319,321,326,323,324,328,330,343,344,345,346,348,350,354,367,368,369,370,373,374,377,379,381,395,396,397,398,403,416,417,406,408,409,412,413], {"55_16_14":0,"55_33_2":0,"86_12_22":0,"87_12_31":0,"102_47_105":0,"109_38_174":0,"109_38_119":0,"111_12_40":0,"109_38_69":0,"110_12_9":0,"115_20_22":0,"115_64_85":0,"115_64_64":0,"116_47_18":0,"119_20_5":0,"119_30_15":0,"120_33_5":0,"122_59_57":0,"123_20_7":0,"126_32_356":0,"126_32_276":0,"126_32_264":0,"129_64_9":0,"126_32_200":0,"126_32_126":0,"163_12_33":0,"180_19_30":0,"180_52_2":0,"209_16_23":0,"209_43_20":0,"209_16_8":0,"209_43_8":0,"237_12_13":0,"242_12_24":0,"242_40_5":0,"242_12_11":0,"244_28_4":0,"247_12_34":0,"248_12_37":0,"247_12_21":0,"248_12_22":0,"249_28_28":0,"249_52_4":0,"252_12_21":0,"253_28_28":0,"253_52_4":0,"273_19_14":0,"273_37_2":0,"278_16_18":0,"278_39_9":0,"323_29_14":0,"323_39_4":0,"345_31_10":0,"345_44_8":0,"345_31_4":0,"348_31_23":0,"348_58_32":0,"370_28_4":0,"370_37_13":0,"373_40_3":0,"373_46_3":0,"374_35_1":0,"374_39_1":0,"395_21_7":0,"395_32_14":0,"396_23_27":0,"396_23_7":0,"396_34_16":0,"397_22_7":0,"397_33_15":0,"403_23_6":0,"411_53_7":0}, ["var gonzales = require('gonzales-pe');","var minimatch = require('minimatch');","var vow = require('vow');","var vfs = require('vow-fs');","","/**"," * @param {Array} predefinedOptions"," * @constructor"," * @name Comb"," */","var Comb = function(predefinedOptions) {","    var _this = this;","    // List of supported syntaxes:","    var supportedSyntaxes = Array.prototype.slice.call(arguments, 1);","    // List of file paths that should be excluded from processing:","    var exclude;","    // List of configured options with values:","    var configuredOptions;","    // List of handlers:","    var handlers;","    // Whether lint mode is on:","    var lint;","    // Whether verbose mode is on:","    var verbose;","    // Map of used options:","    var options = {};","    // List of option names in exact order they should be processed:","    var optionsOrder = [];","    var unmetOptions = {};","","    /**","     * PRIVATE METHODS","     */","","    function usePredefinedOptions() {","        if (!predefinedOptions) return;","","        predefinedOptions.forEach(function(option) {","            _this.use(option);","        });","    }","","    /**","     * @param {Object} option","     */","    function updateOptionOrder(option) {","        var name = option.name;","        var runBefore = option.runBefore;","        var runBeforeIndex;","","        options[name] = option;","","        if (runBefore) {","            runBeforeIndex = optionsOrder.indexOf(runBefore);","            if (runBeforeIndex > -1) {","                optionsOrder.splice(runBeforeIndex, 0, name);","            } else {","                optionsOrder.push(name);","                if (!unmetOptions[runBefore]) unmetOptions[runBefore] = [];","                unmetOptions[runBefore].push(name);","            }","        } else {","            optionsOrder.push(name);","        }","","        var unmet = unmetOptions[name];","        if (unmet) {","            unmet.forEach(function(name) {","                var i = optionsOrder.indexOf(name);","                optionsOrder.splice(i, 1);","                optionsOrder.splice( -1, 0, name);","            });","        }","    }","","    /**","     * Adds an option to list of configured options.","     *","     * @param {Object} option Option's object","     * @param {Object} value Value that should be set for the option","     * @returns {Object} Object with option's name, value and link to","     * `process()` method","     */","    function addHandler(option, value) {","        value = option.setValue ?","            option.setValue(value) :","            setValue(option.accepts, value);","        handlers.push(option);","        configuredOptions[option.name] = value;","    }","","    /**","     * Processes value and checks if it is acceptable by the option.","     *","     * @param {Object} acceptableValues Map of value types that are acceptable","     * by option. If `string` property is present, its value is a regular","     * expression that is used to validate value passed to the function.","     * @param {Object|undefined} value","     * @returns {Boolean|String} Valid option's value","     */","    function setValue(acceptableValues, value) {","        if (!acceptableValues) throw new Error('Option\\'s module must either' +","            ' implement `setValue()` method or provide `accepts` object' +","            ' with acceptable values.');","","        var valueType = typeof value;","        var pattern = acceptableValues[valueType];","","        if (!pattern) throw new Error('The option does not accept values of type \"' +","            valueType + '\".\\nValue\\'s type must be one the following: ' +","            Object.keys(acceptableValues).join(', ') + '.');","","        switch (valueType) {","            case 'boolean':","                if (pattern.indexOf(value) < 0) throw new Error(' Value must be ' +","                    'one of the following: ' + pattern.join(', ') + '.');","                return value;","            case 'number':","                if (value !== parseInt(value)) throw new Error('Value must be an integer.');","                return new Array(value + 1).join(' ');","            case 'string':","                if (!value.match(pattern)) throw new Error('Value must match pattern ' +","                    pattern + '.');","                return value;","            default:","                throw new Error('If you see this message and you are not' +","                    ' a developer adding a new option, please open an issue here:' +","                    ' https://github.com/csscomb/csscomb.js/issues/new' +","                    '\\nFor option to accept values of type \"' + valueType +","                    '\" you need to implement custom `setValue()` method. See' +","                    ' `lib/options/sort-order.js` for example.');","        }","    }","","    /**","     * Checks if path is present in `exclude` list.","     *","     * @param {String} path","     * @returns {Boolean} False if specified path is present in `exclude` list.","     * Otherwise returns true.","     */","    function shouldProcess(path) {","        path = path.replace(/^\\.\\//, '');","        for (var i = exclude.length; i--;) {","            if (exclude[i].match(path)) return false;","        }","        return true;","    }","","    /**","     * Checks if specified path is not present in `exclude` list and it has one of","     * acceptable extensions.","     *","     * @param {String} path","     * @returns {Boolean} False if the path either has unacceptable extension or","     * is present in `exclude` list. True if everything is ok.","     */","    function shouldProcessFile(path) {","        // Get file's extension:","        var syntax = path.split('.').pop();","","        // Check if syntax is supported. If not, ignore the file:","        if (supportedSyntaxes.indexOf(syntax) < 0) {","            return false;","        }","        return shouldProcess(path);","    }","","    /**","     * Processes stylesheet tree node.","     *","     * @param {Array} tree Parsed tree","     * @returns {Array} Modified tree","     */","    function processTree(tree) {","        var _handlers;","","        _handlers = handlers.filter(function(handler) {","            var syntax = _this.getSyntax();","            return handler.syntax.indexOf(syntax) > -1;","        }).map(function(handler) {","            return handler.process;","        });","","        // We walk across complete tree for each handler,","        // because we need strictly maintain order in which handlers work,","        // despite fact that handlers work on different level of the tree.","        _handlers.forEach(function(handler) {","            processNode(['tree', tree], 0, handler);","        });","        return tree;","    }","","    /**","     * Processes tree node.","     *","     * @param {Array} node Tree node","     * @param {Number} level Indent level","     * @param {Object} handler Option's handler","     */","    function processNode(node, level, handler) {","        node.forEach(function(node) {","            if (!Array.isArray(node)) return;","","            var nodeType = node.shift();","            handler.call(_this, nodeType, node, level);","            node.unshift(nodeType);","","            if (nodeType === 'atrulers' || nodeType === 'block') level++;","","            processNode(node, level, handler);","        });","    }","","    /**","     * PUBLIC INSTANCE METHODS","     * Methods that depend on certain instance variables, e.g. configuration:","     *   - use;","     *   - configure;","     *   - getOptionsOrder;","     *   - getValue;","     *   - getSyntax;","     *   - processPath;","     *   - processDirectory;","     *   - processFile;","     *   - processString;","     */","","    /**","     *","     * @param {Object} option","     * @returns {Object} Comb's object","     */","    this.use = function use(option) {","        var name;","","        if (typeof option !== 'object') {","            throw new Error('Can\\'t use option because it is not an object');","        }","","        name = option.name;","        if (typeof name !== 'string' || !name) {","            throw new Error('Can\\'t use option because it has invalid name: ' +","                            name);","        }","","        if (typeof option.accepts !== 'object' &&","            typeof option.setValue !== 'function') {","            throw new Error('Can\\'t use option \"' + name + '\"');","        }","","        if (typeof option.process !== 'function') {","            throw new Error('Can\\'t use option \"' + name + '\"');","        }","","        updateOptionOrder(option);","","        return this;","    };","","    /**","     * Loads configuration from JSON.","     * Activates and configures required options.","     *","     * @param {Object} config","     * @returns {Object} Comb's object (that makes the method chainable).","     */","    this.configure = function configure(config) {","        handlers = [];","        configuredOptions = {};","        verbose = config.verbose;","        lint = config.lint;","        exclude = (config.exclude || []).map(function(pattern) {","            return new minimatch.Minimatch(pattern);","        });","","        optionsOrder.forEach(function(optionName) {","            if (config[optionName] === undefined) return;","","            try {","                addHandler(options[optionName], config[optionName]);","            } catch (e) {","                // Show warnings about illegal config values only in verbose mode:","                if (verbose) {","                    console.warn('\\nFailed to configure \"%s\" option:\\n%s',","                                 optionName, e.message);","                }","            }","        });","","        return this;","    };","","    this.getOptionsOrder = function getOptionsOrder() {","        return optionsOrder.slice();","    };","","    /**","     * Gets option's value.","     *","     * @param {String} optionName","     * @returns {String|Boolean|undefined}","     */","    this.getValue = function getValue(optionName) {","        return configuredOptions[optionName];","    };","","    this.getSyntax = function getSyntax() {","        return _this.syntax;","    };","","    /**","     * Processes directory or file.","     *","     * @param {String} path","     * @returns {Promise}","     */","    this.processPath = function processPath(path) {","        path = path.replace(/\\/$/, '');","","        return vfs.exists(path).then(function(exists) {","            if (!exists) {","                console.warn('Path ' + path + ' was not found.');","                return;","            }","            return vfs.stat(path).then(function(stat) {","                if (stat.isDirectory()) {","                    return _this.processDirectory(path);","                } else {","                    return _this.processFile(path);","                }","            });","        });","    };","","    /**","     * Processes directory recursively.","     *","     * @param {String} path","     * @returns {Promise}","     */","    this.processDirectory = function processDirectory(path) {","        return vfs.listDir(path).then(function(filenames) {","            return vow.all(filenames.map(function(filename) {","                var fullname = path + '/' + filename;","                return vfs.stat(fullname).then(function(stat) {","                    if (stat.isDirectory()) {","                        return shouldProcess(fullname) && _this.processDirectory(fullname);","                    } else {","                        return _this.processFile(fullname);","                    }","                });","            })).then(function(results) {","                return [].concat.apply([], results);","            });","        });","    };","","    /**","     * Processes single file.","     *","     * @param {String} path","     * @returns {Promise}","     */","    this.processFile = function processFile(path) {","        if (!shouldProcessFile(path)) return;","        return vfs.read(path, 'utf8').then(function(data) {","            var syntax = path.split('.').pop();","            var processedData = _this.processString(data, { syntax: syntax, filename: path });","            var isChanged = data !== processedData;","","            if (lint) {","                console.log(isChanged ? '!' : ' ', path);","                return isChanged ? 1 : 0;","            } else if (!isChanged) {","                if (verbose) console.log(' ', path);","                return 0;","            } else {","                return vfs.write(path, processedData, 'utf8').then(function() {","                    if (verbose) console.log('✓', path);","                    return 1;","                });","            }","        });","    };","","    /**","     * Processes a string.","     *","     * @param {String} text","     * @param {{context: String, filename: String, syntax: String}} options","     * @returns {String} Processed string","     */","    this.processString = function processString(text, options) {","        var syntax = options && options.syntax;","        var filename = options && options.filename || '';","        var context = options && options.context;","        var tree;","","        if (!text) return text;","","        // TODO: Parse different syntaxes","        _this.syntax = syntax || 'css';","","        try {","            tree = gonzales.srcToAST({ src: text, syntax: syntax, rule: context });","        } catch (e) {","            var version = require('../package.json').version;","            var message = [filename,","                           e.message,","                          'CSScomb Core version: ' + version];","            e.stack = e.message = message.join('\\n');","            throw e;","        }","","        tree = processTree(tree);","        return gonzales.astToSrc({ syntax: syntax, ast: tree });","    };","","    usePredefinedOptions();","};","","module.exports = Comb;","",""]);
_$jscmd("lib/utils.js", "line", 1);

var gonzales = require("gonzales-pe");

_$jscmd("lib/utils.js", "line", 2);

var minimatch = require("minimatch");

_$jscmd("lib/utils.js", "line", 3);

var vow = require("vow");

_$jscmd("lib/utils.js", "line", 4);

var vfs = require("vow-fs");

_$jscmd("lib/utils.js", "line", 11);

/**
 * @param {Array} predefinedOptions
 * @constructor
 * @name Comb
 */
var Comb = function(predefinedOptions) {
    _$jscmd("lib/utils.js", "line", 12);
    var _this = this;
    _$jscmd("lib/utils.js", "line", 14);
    // List of supported syntaxes:
    var supportedSyntaxes = Array.prototype.slice.call(arguments, 1);
    _$jscmd("lib/utils.js", "line", 16);
    // List of file paths that should be excluded from processing:
    var exclude;
    _$jscmd("lib/utils.js", "line", 18);
    // List of configured options with values:
    var configuredOptions;
    _$jscmd("lib/utils.js", "line", 20);
    // List of handlers:
    var handlers;
    _$jscmd("lib/utils.js", "line", 22);
    // Whether lint mode is on:
    var lint;
    _$jscmd("lib/utils.js", "line", 24);
    // Whether verbose mode is on:
    var verbose;
    _$jscmd("lib/utils.js", "line", 26);
    // Map of used options:
    var options = {};
    _$jscmd("lib/utils.js", "line", 28);
    // List of option names in exact order they should be processed:
    var optionsOrder = [];
    _$jscmd("lib/utils.js", "line", 29);
    var unmetOptions = {};
    /**
     * PRIVATE METHODS
     */
    function usePredefinedOptions() {
        if (!predefinedOptions) return;
        _$jscmd("lib/utils.js", "line", 38);
        predefinedOptions.forEach(function(option) {
            _$jscmd("lib/utils.js", "line", 39);
            _this.use(option);
        });
    }
    /**
     * @param {Object} option
     */
    function updateOptionOrder(option) {
        _$jscmd("lib/utils.js", "line", 47);
        var name = option.name;
        _$jscmd("lib/utils.js", "line", 48);
        var runBefore = option.runBefore;
        _$jscmd("lib/utils.js", "line", 49);
        var runBeforeIndex;
        _$jscmd("lib/utils.js", "line", 51);
        options[name] = option;
        if (runBefore) {
            _$jscmd("lib/utils.js", "line", 54);
            runBeforeIndex = optionsOrder.indexOf(runBefore);
            if (_$jscmd("lib/utils.js", "cond", "55_16_14", runBeforeIndex) > _$jscmd("lib/utils.js", "cond", "55_33_2", -1)) {
                _$jscmd("lib/utils.js", "line", 56);
                optionsOrder.splice(runBeforeIndex, 0, name);
            } else {
                _$jscmd("lib/utils.js", "line", 58);
                optionsOrder.push(name);
                if (!unmetOptions[runBefore]) unmetOptions[runBefore] = [];
                _$jscmd("lib/utils.js", "line", 60);
                unmetOptions[runBefore].push(name);
            }
        } else {
            _$jscmd("lib/utils.js", "line", 63);
            optionsOrder.push(name);
        }
        _$jscmd("lib/utils.js", "line", 66);
        var unmet = unmetOptions[name];
        if (unmet) {
            _$jscmd("lib/utils.js", "line", 68);
            unmet.forEach(function(name) {
                _$jscmd("lib/utils.js", "line", 69);
                var i = optionsOrder.indexOf(name);
                _$jscmd("lib/utils.js", "line", 70);
                optionsOrder.splice(i, 1);
                _$jscmd("lib/utils.js", "line", 71);
                optionsOrder.splice(-1, 0, name);
            });
        }
    }
    /**
     * Adds an option to list of configured options.
     *
     * @param {Object} option Option's object
     * @param {Object} value Value that should be set for the option
     * @returns {Object} Object with option's name, value and link to
     * `process()` method
     */
    function addHandler(option, value) {
        _$jscmd("lib/utils.js", "line", 85);
        value = option.setValue ? _$jscmd("lib/utils.js", "cond", "86_12_22", option.setValue(value)) : _$jscmd("lib/utils.js", "cond", "87_12_31", setValue(option.accepts, value));
        _$jscmd("lib/utils.js", "line", 88);
        handlers.push(option);
        _$jscmd("lib/utils.js", "line", 89);
        configuredOptions[option.name] = value;
    }
    /**
     * Processes value and checks if it is acceptable by the option.
     *
     * @param {Object} acceptableValues Map of value types that are acceptable
     * by option. If `string` property is present, its value is a regular
     * expression that is used to validate value passed to the function.
     * @param {Object|undefined} value
     * @returns {Boolean|String} Valid option's value
     */
    function setValue(acceptableValues, value) {
        if (!acceptableValues) throw new Error(_$jscmd("lib/utils.js", "cond", "102_47_105", "Option's module must either" + " implement `setValue()` method or provide `accepts` object") + " with acceptable values.");
        _$jscmd("lib/utils.js", "line", 106);
        var valueType = typeof value;
        _$jscmd("lib/utils.js", "line", 107);
        var pattern = acceptableValues[valueType];
        if (!pattern) throw new Error(_$jscmd("lib/utils.js", "cond", "109_38_174", _$jscmd("lib/utils.js", "cond", "109_38_119", _$jscmd("lib/utils.js", "cond", "109_38_69", 'The option does not accept values of type "' + _$jscmd("lib/utils.js", "cond", "110_12_9", valueType)) + "\".\nValue's type must be one the following: ") + _$jscmd("lib/utils.js", "cond", "111_12_40", Object.keys(acceptableValues).join(", "))) + ".");
        switch (valueType) {
          case "boolean":
            if (_$jscmd("lib/utils.js", "cond", "115_20_22", pattern.indexOf(value)) < 0) throw new Error(_$jscmd("lib/utils.js", "cond", "115_64_85", _$jscmd("lib/utils.js", "cond", "115_64_64", " Value must be " + "one of the following: ") + _$jscmd("lib/utils.js", "cond", "116_47_18", pattern.join(", "))) + ".");
            _$jscmd("lib/utils.js", "line", 117);
            return value;

          case "number":
            if (_$jscmd("lib/utils.js", "cond", "119_20_5", value) !== _$jscmd("lib/utils.js", "cond", "119_30_15", parseInt(value))) throw new Error("Value must be an integer.");
            _$jscmd("lib/utils.js", "line", 120);
            return new Array(_$jscmd("lib/utils.js", "cond", "120_33_5", value) + 1).join(" ");

          case "string":
            if (!value.match(pattern)) throw new Error(_$jscmd("lib/utils.js", "cond", "122_59_57", "Value must match pattern " + _$jscmd("lib/utils.js", "cond", "123_20_7", pattern)) + ".");
            _$jscmd("lib/utils.js", "line", 124);
            return value;

          default:
            _$jscmd("lib/utils.js", "line", 126);
            throw new Error(_$jscmd("lib/utils.js", "cond", "126_32_356", _$jscmd("lib/utils.js", "cond", "126_32_276", _$jscmd("lib/utils.js", "cond", "126_32_264", _$jscmd("lib/utils.js", "cond", "126_32_200", _$jscmd("lib/utils.js", "cond", "126_32_126", "If you see this message and you are not" + " a developer adding a new option, please open an issue here:") + " https://github.com/csscomb/csscomb.js/issues/new") + '\nFor option to accept values of type "') + _$jscmd("lib/utils.js", "cond", "129_64_9", valueType)) + '" you need to implement custom `setValue()` method. See') + " `lib/options/sort-order.js` for example.");
        }
    }
    /**
     * Checks if path is present in `exclude` list.
     *
     * @param {String} path
     * @returns {Boolean} False if specified path is present in `exclude` list.
     * Otherwise returns true.
     */
    function shouldProcess(path) {
        _$jscmd("lib/utils.js", "line", 143);
        path = path.replace(/^\.\//, "");
        for (var i = exclude.length; i--; ) {
            if (exclude[i].match(path)) return false;
        }
        _$jscmd("lib/utils.js", "line", 147);
        return true;
    }
    /**
     * Checks if specified path is not present in `exclude` list and it has one of
     * acceptable extensions.
     *
     * @param {String} path
     * @returns {Boolean} False if the path either has unacceptable extension or
     * is present in `exclude` list. True if everything is ok.
     */
    function shouldProcessFile(path) {
        _$jscmd("lib/utils.js", "line", 160);
        // Get file's extension:
        var syntax = path.split(".").pop();
        // Check if syntax is supported. If not, ignore the file:
        if (_$jscmd("lib/utils.js", "cond", "163_12_33", supportedSyntaxes.indexOf(syntax)) < 0) {
            _$jscmd("lib/utils.js", "line", 164);
            return false;
        }
        _$jscmd("lib/utils.js", "line", 166);
        return shouldProcess(path);
    }
    /**
     * Processes stylesheet tree node.
     *
     * @param {Array} tree Parsed tree
     * @returns {Array} Modified tree
     */
    function processTree(tree) {
        _$jscmd("lib/utils.js", "line", 176);
        var _handlers;
        _$jscmd("lib/utils.js", "line", 178);
        _handlers = handlers.filter(function(handler) {
            _$jscmd("lib/utils.js", "line", 179);
            var syntax = _this.getSyntax();
            _$jscmd("lib/utils.js", "line", 180);
            return _$jscmd("lib/utils.js", "cond", "180_19_30", handler.syntax.indexOf(syntax)) > _$jscmd("lib/utils.js", "cond", "180_52_2", -1);
        }).map(function(handler) {
            _$jscmd("lib/utils.js", "line", 182);
            return handler.process;
        });
        _$jscmd("lib/utils.js", "line", 188);
        // We walk across complete tree for each handler,
        // because we need strictly maintain order in which handlers work,
        // despite fact that handlers work on different level of the tree.
        _handlers.forEach(function(handler) {
            _$jscmd("lib/utils.js", "line", 189);
            processNode([ "tree", tree ], 0, handler);
        });
        _$jscmd("lib/utils.js", "line", 191);
        return tree;
    }
    /**
     * Processes tree node.
     *
     * @param {Array} node Tree node
     * @param {Number} level Indent level
     * @param {Object} handler Option's handler
     */
    function processNode(node, level, handler) {
        _$jscmd("lib/utils.js", "line", 202);
        node.forEach(function(node) {
            if (!Array.isArray(node)) return;
            _$jscmd("lib/utils.js", "line", 205);
            var nodeType = node.shift();
            _$jscmd("lib/utils.js", "line", 206);
            handler.call(_this, nodeType, node, level);
            _$jscmd("lib/utils.js", "line", 207);
            node.unshift(nodeType);
            if (_$jscmd("lib/utils.js", "cond", "209_16_23", _$jscmd("lib/utils.js", "cond", "209_16_8", nodeType) === "atrulers") || _$jscmd("lib/utils.js", "cond", "209_43_20", _$jscmd("lib/utils.js", "cond", "209_43_8", nodeType) === "block")) level++;
            _$jscmd("lib/utils.js", "line", 211);
            processNode(node, level, handler);
        });
    }
    _$jscmd("lib/utils.js", "line", 234);
    /**
     * PUBLIC INSTANCE METHODS
     * Methods that depend on certain instance variables, e.g. configuration:
     *   - use;
     *   - configure;
     *   - getOptionsOrder;
     *   - getValue;
     *   - getSyntax;
     *   - processPath;
     *   - processDirectory;
     *   - processFile;
     *   - processString;
     */
    /**
     *
     * @param {Object} option
     * @returns {Object} Comb's object
     */
    this.use = function use(option) {
        _$jscmd("lib/utils.js", "line", 235);
        var name;
        if (_$jscmd("lib/utils.js", "cond", "237_12_13", typeof option) !== "object") {
            _$jscmd("lib/utils.js", "line", 238);
            throw new Error("Can't use option because it is not an object");
        }
        _$jscmd("lib/utils.js", "line", 241);
        name = option.name;
        if (_$jscmd("lib/utils.js", "cond", "242_12_24", _$jscmd("lib/utils.js", "cond", "242_12_11", typeof name) !== "string") || _$jscmd("lib/utils.js", "cond", "242_40_5", !name)) {
            _$jscmd("lib/utils.js", "line", 243);
            throw new Error("Can't use option because it has invalid name: " + _$jscmd("lib/utils.js", "cond", "244_28_4", name));
        }
        if (_$jscmd("lib/utils.js", "cond", "247_12_34", _$jscmd("lib/utils.js", "cond", "247_12_21", typeof option.accepts) !== "object") && _$jscmd("lib/utils.js", "cond", "248_12_37", _$jscmd("lib/utils.js", "cond", "248_12_22", typeof option.setValue) !== "function")) {
            _$jscmd("lib/utils.js", "line", 249);
            throw new Error(_$jscmd("lib/utils.js", "cond", "249_28_28", "Can't use option \"" + _$jscmd("lib/utils.js", "cond", "249_52_4", name)) + '"');
        }
        if (_$jscmd("lib/utils.js", "cond", "252_12_21", typeof option.process) !== "function") {
            _$jscmd("lib/utils.js", "line", 253);
            throw new Error(_$jscmd("lib/utils.js", "cond", "253_28_28", "Can't use option \"" + _$jscmd("lib/utils.js", "cond", "253_52_4", name)) + '"');
        }
        _$jscmd("lib/utils.js", "line", 256);
        updateOptionOrder(option);
        _$jscmd("lib/utils.js", "line", 258);
        return this;
    };
    _$jscmd("lib/utils.js", "line", 268);
    /**
     * Loads configuration from JSON.
     * Activates and configures required options.
     *
     * @param {Object} config
     * @returns {Object} Comb's object (that makes the method chainable).
     */
    this.configure = function configure(config) {
        _$jscmd("lib/utils.js", "line", 269);
        handlers = [];
        _$jscmd("lib/utils.js", "line", 270);
        configuredOptions = {};
        _$jscmd("lib/utils.js", "line", 271);
        verbose = config.verbose;
        _$jscmd("lib/utils.js", "line", 272);
        lint = config.lint;
        _$jscmd("lib/utils.js", "line", 273);
        exclude = (_$jscmd("lib/utils.js", "cond", "273_19_14", config.exclude) || _$jscmd("lib/utils.js", "cond", "273_37_2", [])).map(function(pattern) {
            _$jscmd("lib/utils.js", "line", 274);
            return new minimatch.Minimatch(pattern);
        });
        _$jscmd("lib/utils.js", "line", 277);
        optionsOrder.forEach(function(optionName) {
            if (_$jscmd("lib/utils.js", "cond", "278_16_18", config[optionName]) === _$jscmd("lib/utils.js", "cond", "278_39_9", undefined)) return;
            try {
                _$jscmd("lib/utils.js", "line", 281);
                addHandler(options[optionName], config[optionName]);
            } catch (e) {
                // Show warnings about illegal config values only in verbose mode:
                if (verbose) {
                    _$jscmd("lib/utils.js", "line", 285);
                    console.warn('\nFailed to configure "%s" option:\n%s', optionName, e.message);
                }
            }
        });
        _$jscmd("lib/utils.js", "line", 291);
        return this;
    };
    _$jscmd("lib/utils.js", "line", 294);
    this.getOptionsOrder = function getOptionsOrder() {
        _$jscmd("lib/utils.js", "line", 295);
        return optionsOrder.slice();
    };
    _$jscmd("lib/utils.js", "line", 304);
    /**
     * Gets option's value.
     *
     * @param {String} optionName
     * @returns {String|Boolean|undefined}
     */
    this.getValue = function getValue(optionName) {
        _$jscmd("lib/utils.js", "line", 305);
        return configuredOptions[optionName];
    };
    _$jscmd("lib/utils.js", "line", 308);
    this.getSyntax = function getSyntax() {
        _$jscmd("lib/utils.js", "line", 309);
        return _this.syntax;
    };
    _$jscmd("lib/utils.js", "line", 318);
    /**
     * Processes directory or file.
     *
     * @param {String} path
     * @returns {Promise}
     */
    this.processPath = function processPath(path) {
        _$jscmd("lib/utils.js", "line", 319);
        path = path.replace(/\/$/, "");
        _$jscmd("lib/utils.js", "line", 321);
        return vfs.exists(path).then(function(exists) {
            if (!exists) {
                _$jscmd("lib/utils.js", "line", 323);
                console.warn(_$jscmd("lib/utils.js", "cond", "323_29_14", "Path " + _$jscmd("lib/utils.js", "cond", "323_39_4", path)) + " was not found.");
                _$jscmd("lib/utils.js", "line", 324);
                return;
            }
            _$jscmd("lib/utils.js", "line", 326);
            return vfs.stat(path).then(function(stat) {
                if (stat.isDirectory()) {
                    _$jscmd("lib/utils.js", "line", 328);
                    return _this.processDirectory(path);
                } else {
                    _$jscmd("lib/utils.js", "line", 330);
                    return _this.processFile(path);
                }
            });
        });
    };
    _$jscmd("lib/utils.js", "line", 342);
    /**
     * Processes directory recursively.
     *
     * @param {String} path
     * @returns {Promise}
     */
    this.processDirectory = function processDirectory(path) {
        _$jscmd("lib/utils.js", "line", 343);
        return vfs.listDir(path).then(function(filenames) {
            _$jscmd("lib/utils.js", "line", 344);
            return vow.all(filenames.map(function(filename) {
                _$jscmd("lib/utils.js", "line", 345);
                var fullname = _$jscmd("lib/utils.js", "cond", "345_31_10", _$jscmd("lib/utils.js", "cond", "345_31_4", path) + "/") + _$jscmd("lib/utils.js", "cond", "345_44_8", filename);
                _$jscmd("lib/utils.js", "line", 346);
                return vfs.stat(fullname).then(function(stat) {
                    if (stat.isDirectory()) {
                        _$jscmd("lib/utils.js", "line", 348);
                        return _$jscmd("lib/utils.js", "cond", "348_31_23", shouldProcess(fullname)) && _$jscmd("lib/utils.js", "cond", "348_58_32", _this.processDirectory(fullname));
                    } else {
                        _$jscmd("lib/utils.js", "line", 350);
                        return _this.processFile(fullname);
                    }
                });
            })).then(function(results) {
                _$jscmd("lib/utils.js", "line", 354);
                return [].concat.apply([], results);
            });
        });
    };
    _$jscmd("lib/utils.js", "line", 365);
    /**
     * Processes single file.
     *
     * @param {String} path
     * @returns {Promise}
     */
    this.processFile = function processFile(path) {
        if (!shouldProcessFile(path)) return;
        _$jscmd("lib/utils.js", "line", 367);
        return vfs.read(path, "utf8").then(function(data) {
            _$jscmd("lib/utils.js", "line", 368);
            var syntax = path.split(".").pop();
            _$jscmd("lib/utils.js", "line", 369);
            var processedData = _this.processString(data, {
                syntax: syntax,
                filename: path
            });
            _$jscmd("lib/utils.js", "line", 370);
            var isChanged = _$jscmd("lib/utils.js", "cond", "370_28_4", data) !== _$jscmd("lib/utils.js", "cond", "370_37_13", processedData);
            if (lint) {
                _$jscmd("lib/utils.js", "line", 373);
                console.log(isChanged ? _$jscmd("lib/utils.js", "cond", "373_40_3", "!") : _$jscmd("lib/utils.js", "cond", "373_46_3", " "), path);
                _$jscmd("lib/utils.js", "line", 374);
                return isChanged ? _$jscmd("lib/utils.js", "cond", "374_35_1", 1) : _$jscmd("lib/utils.js", "cond", "374_39_1", 0);
            } else if (!isChanged) {
                if (verbose) console.log(" ", path);
                _$jscmd("lib/utils.js", "line", 377);
                return 0;
            } else {
                _$jscmd("lib/utils.js", "line", 379);
                return vfs.write(path, processedData, "utf8").then(function() {
                    if (verbose) console.log("✓", path);
                    _$jscmd("lib/utils.js", "line", 381);
                    return 1;
                });
            }
        });
    };
    _$jscmd("lib/utils.js", "line", 394);
    /**
     * Processes a string.
     *
     * @param {String} text
     * @param {{context: String, filename: String, syntax: String}} options
     * @returns {String} Processed string
     */
    this.processString = function processString(text, options) {
        _$jscmd("lib/utils.js", "line", 395);
        var syntax = _$jscmd("lib/utils.js", "cond", "395_21_7", options) && _$jscmd("lib/utils.js", "cond", "395_32_14", options.syntax);
        _$jscmd("lib/utils.js", "line", 396);
        var filename = _$jscmd("lib/utils.js", "cond", "396_23_27", _$jscmd("lib/utils.js", "cond", "396_23_7", options) && _$jscmd("lib/utils.js", "cond", "396_34_16", options.filename)) || "";
        _$jscmd("lib/utils.js", "line", 397);
        var context = _$jscmd("lib/utils.js", "cond", "397_22_7", options) && _$jscmd("lib/utils.js", "cond", "397_33_15", options.context);
        _$jscmd("lib/utils.js", "line", 398);
        var tree;
        if (!text) return text;
        _$jscmd("lib/utils.js", "line", 403);
        // TODO: Parse different syntaxes
        _this.syntax = _$jscmd("lib/utils.js", "cond", "403_23_6", syntax) || "css";
        try {
            _$jscmd("lib/utils.js", "line", 406);
            tree = gonzales.srcToAST({
                src: text,
                syntax: syntax,
                rule: context
            });
        } catch (e) {
            _$jscmd("lib/utils.js", "line", 408);
            var version = require("../package.json").version;
            _$jscmd("lib/utils.js", "line", 409);
            var message = [ filename, e.message, "CSScomb Core version: " + _$jscmd("lib/utils.js", "cond", "411_53_7", version) ];
            _$jscmd("lib/utils.js", "line", 412);
            e.stack = e.message = message.join("\n");
            _$jscmd("lib/utils.js", "line", 413);
            throw e;
        }
        _$jscmd("lib/utils.js", "line", 416);
        tree = processTree(tree);
        _$jscmd("lib/utils.js", "line", 417);
        return gonzales.astToSrc({
            syntax: syntax,
            ast: tree
        });
    };
    _$jscmd("lib/utils.js", "line", 420);
    usePredefinedOptions();
};

_$jscmd("lib/utils.js", "line", 423);

module.exports = Comb;